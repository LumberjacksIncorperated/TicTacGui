
Design Decisions For Conditions
-------------------------------

	1. Module Sections

	Sections are:
		1/ IMPORTS
		2/ TEST FLAG
		3/ IMPLEMENTATION
			3.1/ CONSTANTS
			3.2/ SUPPORT METHODS
			3.3/ EXPORTED METHODS
		4/ TESTING
		5/ TESTING DRIVER

	The implementation is split into three sections in order to declutter both the class constants, as well as the exported methods
	from the rest of the code, so what has been exported can be found easily

	2. Using A Dictionary For Marker Tokens

	Originally I had implemented the marker tokens as:

		    EMPTY_VALUE = 0
    		PLAYER_TOKEN_VALUE = [1, 2]

    There were several problems with this:
    	1/ The empty value is seperated from the player token values in code, which means that might be changed without reference to eachother
    	2/ You have to understand the logical connection between them to understand there is a connection between them in the code
    	3/ The naming of them does not suggest a connection either

    To fix this, I included them in the same construct, which:
    	1/ Connects them in the code
    	2/ Provided apt naming that more accurately describes the units and thier connection
    	3/ Index them as a dictionary with a string keys, to provide more description so it is immediate in understanding the code lines

    	Example use:

    		Board._MARKER_TOKENS["PLAYER_ONE"]

    	We can immediately see from the code that we are getting the board marker token for player one!